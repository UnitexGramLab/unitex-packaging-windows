diff -ru a/nsis-3.0a2-src/Source/icon.cpp b/nsis-3.0a2-src/Source/icon.cpp
--- a/nsis-3.0a2-src/Source/icon.cpp	2013-12-08 15:34:38.000000000 +0100
+++ b/nsis-3.0a2-src/Source/icon.cpp	2015-09-17 16:30:07.000000000 +0200
@@ -1,4 +1,19 @@
-// Unicode support by Jim Park -- 11/16/2007
+/*
+ * icon.cpp
+ * 
+ * This file is a part of NSIS.
+ * 
+ * Copyright (C) 1999-2015 Nullsoft and Contributors
+ * 
+ * Licensed under the zlib/libpng license (the "License");
+ * you may not use this file except in compliance with the License.
+ * 
+ * Licence details can be found in the file COPYING.
+ * 
+ * This software is provided 'as-is', without any express or implied
+ * warranty.
+ */
+
 
 #include "Platform.h"
 #include "icon.h"
@@ -213,7 +228,7 @@
       FIX_ENDIAN_INT32(sorted_icons1[i].meta.dwRawSize),
       FIX_ENDIAN_INT32(sorted_icons2[i].meta.dwRawSize)
     );
-    pair.size_index = i;
+    pair.size_index = truncate_cast(unsigned int,i);
 
     result.push_back(pair);
   }
@@ -227,7 +242,7 @@
       pair.index1 = sorted_icons1[i].index;
       pair.index2 = 0xffff;
       pair.size = FIX_ENDIAN_INT32(sorted_icons1[i].meta.dwRawSize);
-      pair.size_index = i;
+      pair.size_index = truncate_cast(unsigned int,i);
     }
 
     if (i < sorted_icons2.size())
@@ -235,7 +250,7 @@
       pair.index2 = sorted_icons2[i].index;
       pair.index1 = 0xffff;
       pair.size = FIX_ENDIAN_INT32(sorted_icons2[i].meta.dwRawSize);
-      pair.size_index = i;
+      pair.size_index = truncate_cast(unsigned int,i);
     }
 
     result.push_back(pair);
@@ -256,7 +271,7 @@
 
   header->wReserved = 0;
   header->wIsIcon   = FIX_ENDIAN_INT16(1);
-  header->wCount    = FIX_ENDIAN_INT16(icon.size());
+  header->wCount    = FIX_ENDIAN_INT16((WORD)icon.size());
 
   order = sort_pairs(order, first);
 
@@ -285,7 +300,7 @@
   size_t group_size = sizeof(IconGroupHeader) // header
     + order.size() * SIZEOF_RSRC_ICON_GROUP_ENTRY; // entries
 
-  re->UpdateResource(RT_GROUP_ICON, wIconId, NSIS_DEFAULT_LANG, group1, group_size);
+  re->UpdateResource(RT_GROUP_ICON, wIconId, NSIS_DEFAULT_LANG, group1, (DWORD)group_size);
   destroy_icon_group(group1);
 
   // delete old icons
@@ -343,7 +358,7 @@
   LPBYTE seeker = uninst_data;
 
   // fill group header
-  *(LPDWORD) seeker = FIX_ENDIAN_INT32(group_size);
+  *(LPDWORD) seeker = FIX_ENDIAN_INT32((UINT32)group_size);
   seeker += sizeof(DWORD);
   *(LPDWORD) seeker = 0;
   seeker += sizeof(DWORD);
@@ -382,7 +397,7 @@
     DWORD offset;
     DWORD size;
 
-    CResourceEditor re(exeHeader, exeHeaderSize, false);
+    CResourceEditor re(exeHeader, (DWORD)exeHeaderSize, false);
 
     LPBYTE seeker = uninstIconData;
 
diff -ru a/nsis-3.0a2-src/Source/Platform.h b/nsis-3.0a2-src/Source/Platform.h
--- a/nsis-3.0a2-src/Source/Platform.h	2013-12-25 05:50:54.000000000 +0100
+++ b/nsis-3.0a2-src/Source/Platform.h	2016-03-31 17:03:02.125385289 +0200
@@ -3,7 +3,7 @@
  * 
  * This file is a part of NSIS.
  * 
- * Copyright (C) 1999-2013 Nullsoft and Contributors
+ * Copyright (C) 1999-2015 Nullsoft and Contributors
  * 
  * Licensed under the zlib/libpng license (the "License");
  * you may not use this file except in compliance with the License.
@@ -22,8 +22,8 @@
 // some definitions for non Win32 platforms were taken from MinGW's free Win32 library
 
 
-#if defined(__cplusplus) && defined(MAKENSIS) && !defined(_MSC_VER)
-template<class T> class NSISCHARTYPE{ T _c; public: NSISCHARTYPE(){} NSISCHARTYPE(T c):_c(c){} operator T()const{ return _c; } operator int()const{ return (int) _c; } operator bool()const{ return _c != 0; } };
+#if defined(__cplusplus) && defined(MAKENSIS) && (!defined(_MSC_VER) || _MSC_VER > 1200)
+template<class T> class NSISCHARTYPE{ T _c; public: NSISCHARTYPE(){} NSISCHARTYPE(T c):_c(c){} operator T()const{ return _c; } };
 typedef NSISCHARTYPE<unsigned short> WINWCHAR; // WINWCHAR is always UTF16LE and should not be passed to wcs* functions
 #else
 typedef unsigned short WINWCHAR;
@@ -41,32 +41,27 @@
 #include <shlwapi.h>
 #include <shlobj.h>
 #else
+#  include <stdint.h>
 #  ifndef EXEHEAD
 #    include <string.h>
 #    include <stdlib.h>
 #  endif
 // basic types
-typedef unsigned char BYTE, *PBYTE, *LPBYTE;
-typedef unsigned short WORD, *LPWORD;
-typedef unsigned long DWORD, *LPDWORD;
-typedef short SHORT;
-typedef unsigned short USHORT;
-typedef unsigned int UINT;
-typedef unsigned int UINT32;
-typedef int INT;
-typedef int INT32;
-typedef long LONG;
-typedef unsigned long ULONG;
-typedef long long INT64, LARGE_INTEGER;
-typedef unsigned long long UINT64, ULARGE_INTEGER;
-#include <stdint.h>
-#ifdef INTPTR_MAX
+typedef uint8_t BYTE, *PBYTE, *LPBYTE;
+typedef uint16_t WORD, *LPWORD;
+typedef uint32_t DWORD, *LPDWORD;
+typedef int16_t SHORT;
+typedef uint16_t USHORT;
+typedef uint32_t UINT;
+typedef uint32_t UINT32;
+typedef int32_t INT;
+typedef int32_t INT32;
+typedef int32_t LONG;
+typedef uint32_t ULONG;
+typedef int64_t INT64, LARGE_INTEGER;
+typedef uint64_t UINT64, ULARGE_INTEGER;
 typedef intptr_t INT_PTR;
 typedef uintptr_t UINT_PTR;
-#else
-typedef int INT_PTR;
-typedef unsigned int UINT_PTR;
-#endif
 typedef int BOOL, *LPBOOL;
 typedef short VARIANT_BOOL;
 typedef void VOID;
@@ -88,7 +83,7 @@
 typedef unsigned long HKEY;
 // some gdi
 typedef DWORD COLORREF;
-typedef UINT32 HBRUSH;
+typedef HANDLE HBRUSH;
 // bool
 #  define FALSE 0
 #  define TRUE 1
@@ -135,7 +130,7 @@
 
 #ifdef __cplusplus
 #include <algorithm>
-#if defined(_MSC_VER) && _MSC_VER <= 1200
+#if defined(_MSC_VER) && ( _MSC_VER <= 1200 || (defined(_MIN) && _MSC_FULL_VER >= 140000000 && _MSC_FULL_VER <= 140040310) )
 #define STD_MIN std::_MIN
 #define STD_MAX std::_MAX
 #else
@@ -144,23 +139,32 @@
 #endif
 #endif
 
-#ifdef _countof
-#define COUNTOF _countof
-#else
+#ifndef COUNTOF
 #define COUNTOF(a) (sizeof(a)/sizeof(a[0]))
 #endif
 
 #ifndef __BIG_ENDIAN__
+# define FIX_ENDIAN_INT64(x) (x)
 # define FIX_ENDIAN_INT32_INPLACE(x) ((void)(x))
 # define FIX_ENDIAN_INT32(x) (x)
 # define FIX_ENDIAN_INT16_INPLACE(x) ((void)(x))
 # define FIX_ENDIAN_INT16(x) (x)
 #else
+# define FIX_ENDIAN_INT64(x) SWAP_ENDIAN_INT64(x)
 # define FIX_ENDIAN_INT32_INPLACE(x) ((x) = SWAP_ENDIAN_INT32(x))
 # define FIX_ENDIAN_INT32(x) SWAP_ENDIAN_INT32(x)
 # define FIX_ENDIAN_INT16_INPLACE(x) ((x) = SWAP_ENDIAN_INT16(x))
 # define FIX_ENDIAN_INT16(x) SWAP_ENDIAN_INT16(x)
 #endif
+#define SWAP_ENDIAN_INT64(x) ( \
+  (((x)&0xFF00000000000000) >> 56) | \
+  (((x)&0x00FF000000000000) >> 40) | \
+  (((x)&0x0000FF0000000000) >> 24) | \
+  (((x)&0x000000FF00000000) >>  8) | \
+  (((x)&0x00000000FF000000) <<  8) | \
+  (((x)&0x0000000000FF0000) << 24) | \
+  (((x)&0x000000000000FF00) << 40) | \
+  (((x)&0x00000000000000FF) << 56) )
 #define SWAP_ENDIAN_INT32(x) ( \
   (((x)&0xFF000000) >> 24) | \
   (((x)&0x00FF0000) >>  8) | \
@@ -217,7 +221,7 @@
 
 #ifndef _WIN32
 #  ifndef FIELD_OFFSET
-#    define FIELD_OFFSET(t,f) ((LONG)&(((t*)0)->f))
+#    define FIELD_OFFSET(t,f) ((UINT_PTR)&(((t*)0)->f))
 #  endif
 #  ifndef MAKEINTRESOURCEA
 #    define MAKEINTRESOURCEA(i) ((LPSTR)((ULONG_PTR)((WORD)(i))))
@@ -504,6 +508,9 @@
 #ifndef COLOR_WINDOW
 #  define COLOR_WINDOW 5
 #endif
+#ifndef COLOR_HOTLIGHT
+#  define COLOR_HOTLIGHT 26
+#endif
 
 // resources
 
@@ -770,6 +777,15 @@
 #  define IMAGE_DIRECTORY_ENTRY_EXPORT 0
 #  define IMAGE_SIZEOF_SHORT_NAME 8
 #endif
+#ifndef IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
+#define IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE 0x0040
+#endif
+#ifndef IMAGE_DLLCHARACTERISTICS_NX_COMPAT
+#define IMAGE_DLLCHARACTERISTICS_NX_COMPAT 0x0100
+#endif
+#ifndef IMAGE_DLLCHARACTERISTICS_NO_SEH
+#define IMAGE_DLLCHARACTERISTICS_NO_SEH 0x0400
+#endif
 #ifndef IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE
 #define IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE 0x8000
 #endif
@@ -830,7 +846,7 @@
   DWORD VirtualAddress;
   DWORD Size;
 } IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;
-typedef struct _IMAGE_OPTIONAL_HEADER {
+typedef struct _IMAGE_OPTIONAL_HEADER32 {
   WORD Magic;
   BYTE MajorLinkerVersion;
   BYTE MinorLinkerVersion;
@@ -895,25 +911,34 @@
   DWORD NumberOfRvaAndSizes;
   IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
 } IMAGE_OPTIONAL_HEADER64,*PIMAGE_OPTIONAL_HEADER64;
+typedef struct _IMAGE_NT_HEADERS32 {
+  DWORD Signature;
+  IMAGE_FILE_HEADER FileHeader;
+  IMAGE_OPTIONAL_HEADER32 OptionalHeader;
+} IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32;
+typedef struct _IMAGE_NT_HEADERS64 {
+  DWORD Signature;
+  IMAGE_FILE_HEADER FileHeader;
+  IMAGE_OPTIONAL_HEADER64 OptionalHeader;
+} IMAGE_NT_HEADERS64,*PIMAGE_NT_HEADERS64;
 #ifdef _WIN64
-typedef IMAGE_OPTIONAL_HEADER64         IMAGE_OPTIONAL_HEADER;
-typedef PIMAGE_OPTIONAL_HEADER64        PIMAGE_OPTIONAL_HEADER;
+typedef IMAGE_OPTIONAL_HEADER64  IMAGE_OPTIONAL_HEADER;
+typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;
+typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
+typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;
 #else
-typedef IMAGE_OPTIONAL_HEADER32         IMAGE_OPTIONAL_HEADER;
-typedef PIMAGE_OPTIONAL_HEADER32        PIMAGE_OPTIONAL_HEADER;
+typedef IMAGE_OPTIONAL_HEADER32  IMAGE_OPTIONAL_HEADER;
+typedef PIMAGE_OPTIONAL_HEADER32 PIMAGE_OPTIONAL_HEADER;
+typedef IMAGE_NT_HEADERS32  IMAGE_NT_HEADERS;
+typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;
 #endif
 #ifndef __BIG_ENDIAN__
-#  define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b
-#  define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
+#  define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x010b
+#  define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x020b
 #else
 #  define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x0b01
 #  define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x0b02
 #endif
-typedef struct _IMAGE_NT_HEADERS {
-  DWORD Signature;
-  IMAGE_FILE_HEADER FileHeader;
-  IMAGE_OPTIONAL_HEADER OptionalHeader;
-} IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;
 typedef struct _IMAGE_SECTION_HEADER {
   BYTE Name[IMAGE_SIZEOF_SHORT_NAME];
  union {
@@ -998,25 +1023,26 @@
 
 
 #define NSIS_CXX_THROWSPEC(ignoredthrowspec) // Ignore c++ exception specifications
+#define BUGBUG64TRUNCATE(cast,xpr) ( (cast) (xpr) )
 
 /*
 _tprintf on Windows/MSVCRT treats %s as TCHAR* and on POSIX %s is always char*!
-Always use our NPRI* (NsisPRInt[Narrow|Wide]*) defines in format strings when calling 
+Always use our NPRI* (NsisPRInt*[Narrow|Wide]) defines in format strings when calling 
 functions from tchar.h (Similar to the way <inttypes.h> works)
 
 Example: _tprintf(_T("Hello %") NPRIs _T("\n"), _T("World"));
 */
 #ifdef _WIN32
 #  define NPRIs _T("s")
-#  define NPRINs _T("hs")
-#  define NPRIWs _T("ls") // ws also works, not sure which is most compatible
+#  define NPRIns _T("hs")
+#  define NPRIws _T("ls") // ws also works, not sure which is most compatible
 #  ifndef _WIN64
 #    define NPRIp _T(".8x")
-#    define NPRINp ".8x"
+#    define NPRIpN ".8x"
 #  endif
 #else  // !_WIN32
-#  define NPRINs _T("s")
-#  define NPRIWs _T("ls")
+#  define NPRIns _T("s")
+#  define NPRIws _T("ls")
 #  ifdef _UNICODE
 #    define NPRIs _T("ls")
 #  else // !_UNICODE
@@ -1025,7 +1051,20 @@
 #endif // ~_WIN32
 #ifndef NPRIp
 #  define NPRIp _T("p")
-#  define NPRINp "p"
+#  define NPRIpN "p"
 #endif
 
+
+// Disable deprecated warnings (Windows SDK for Windows 8.1)
+#ifdef _MSC_VER
+#if _MSC_VER >= 1500
+FORCEINLINE DWORD NoDepr_GetVersion() { __pragma(warning(push))__pragma(warning(disable:4996)) DWORD r = GetVersion(); __pragma(warning(pop)) return r; }
+#define GetVersion NoDepr_GetVersion
+FORCEINLINE BOOL NoDepr_GetVersionExA(OSVERSIONINFOA*p) { __pragma(warning(push))__pragma(warning(disable:4996)) BOOL r = GetVersionExA(p); __pragma(warning(pop)) return r; }
+#define GetVersionExA NoDepr_GetVersionExA
+FORCEINLINE BOOL NoDepr_GetVersionExW(OSVERSIONINFOW*p) { __pragma(warning(push))__pragma(warning(disable:4996)) BOOL r = GetVersionExW(p); __pragma(warning(pop)) return r; }
+#define GetVersionExW NoDepr_GetVersionExW
+#endif //~ _MSC_VER >= 1500
+#endif //~ _MSC_VER
+
 #endif // EOF
diff -ru a/nsis-3.0a2-src/Source/util.cpp b/nsis-3.0a2-src/Source/util.cpp
--- a/nsis-3.0a2-src/Source/util.cpp	2013-12-08 15:34:38.000000000 +0100
+++ b/nsis-3.0a2-src/Source/util.cpp	2016-03-31 17:05:03.581639947 +0200
@@ -461,8 +461,8 @@
 {
   switch(code_page)
   {
-  case CP_ACP:   _sntprintf(buf, len, _T("%") NPRINs, iconv_ACP); return;
-  case CP_OEMCP: _sntprintf(buf, len, _T("%") NPRINs, iconv_OEM); return;
+  case CP_ACP:   _sntprintf(buf, len, _T("%") NPRIns, iconv_ACP); return;
+  case CP_OEMCP: _sntprintf(buf, len, _T("%") NPRIns, iconv_OEM); return;
   case CP_UTF8:  _sntprintf(buf, len, _T("UTF-8")); return;
   case 1200: // UTF16LE
   case 1201: // UTF16BE
diff -ru a/nsis-3.0a2-src/Source/util.h b/nsis-3.0a2-src/Source/util.h
--- a/nsis-3.0a2-src/Source/util.h	2013-12-25 05:50:54.000000000 +0100
+++ b/nsis-3.0a2-src/Source/util.h	2016-03-31 16:52:16.628129813 +0200
@@ -3,7 +3,7 @@
  * 
  * This file is a part of NSIS.
  * 
- * Copyright (C) 1999-2013 Nullsoft and Contributors
+ * Copyright (C) 1999-2015 Nullsoft and Contributors
  * 
  * Licensed under the zlib/libpng license (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,7 +33,7 @@
 #include <stdarg.h>
 
 extern double my_wtof(const wchar_t *str);
-extern unsigned int my_strncpy(TCHAR*Dest, const TCHAR*Src, unsigned int cchMax);
+extern size_t my_strncpy(TCHAR*Dest, const TCHAR*Src, size_t cchMax);
 size_t my_strftime(TCHAR *s, size_t max, const TCHAR  *fmt, const struct tm *tm);
 
 // Adds the bitmap in filename using resource editor re as id id.
@@ -45,13 +45,23 @@
 tstring get_full_path(const tstring& path);
 tstring get_dir_name(const tstring& path);
 tstring get_file_name(const tstring& path);
+tstring get_executable_path(const TCHAR* argv0);
 tstring get_executable_dir(const TCHAR *argv0);
 tstring remove_file_extension(const tstring& path);
-tstring lowercase(const tstring&);
+tstring& path_append_separator(tstring& path);
+tstring& path_append(tstring& base, const TCHAR* more);
+inline tstring& path_append(tstring& base, const tstring& more) { return path_append(base, more.c_str()); }
+#ifdef _WIN32
+#define IsPathSeparator IsAgnosticPathSeparator
+#else
+#define IsPathSeparator(c) ( PLATFORM_PATH_SEPARATOR_C == (c) )
+#endif
+inline bool IsAgnosticPathSeparator(const TCHAR c) { return _T('\\') == c || _T('/') == c; }
+bool IsWindowsPathRelative(const TCHAR *p);
 
+tstring lowercase(const tstring&);
 tstring get_string_prefix(const tstring& str, const tstring& separator);
 tstring get_string_suffix(const tstring& str, const tstring& separator);
-
 void RawTStrToASCII(const TCHAR*in,char*out,UINT maxcch);
 size_t ExpandoStrFmtVaList(wchar_t*Stack, size_t cchStack, wchar_t**ppMalloc, const wchar_t*FmtStr, va_list Args);
 
@@ -77,6 +87,22 @@
   operator T*() { return GetPtr(); }
 };
 
+typedef enum {
+  GFSF_BYTESIFPOSSIBLE = 0x1,
+  GFSF_HIDEBYTESCALE   = 0x2,
+  GFSF_DEFAULT = 0
+} GETFRIENDLYSIZEFLAGS;
+const TCHAR* GetFriendlySize(UINT64 n, unsigned int&fn, GETFRIENDLYSIZEFLAGS f = GFSF_DEFAULT);
+class FriendlySize {
+  const TCHAR* m_s;
+  unsigned int m_n;
+public:
+  FriendlySize(UINT64 n, size_t f = GFSF_DEFAULT) { Calculate(n, f); }
+  void Calculate(UINT64 n, size_t f) { m_s = GetFriendlySize(n, m_n, (GETFRIENDLYSIZEFLAGS)f); }
+  unsigned int UInt() const { return m_n; }
+  const TCHAR* Scale() const { return m_s; }
+};
+
 int sane_system(const TCHAR *command);
 
 void PrintColorFmtMsg(unsigned int type, const TCHAR *fmtstr, va_list args);
@@ -84,6 +110,7 @@
 #ifdef _WIN32
 #ifdef _UNICODE
 int RunChildProcessRedirected(LPCWSTR cmdprefix, LPCWSTR cmdmain);
+inline int RunChildProcessRedirected(LPCWSTR cmd) { return RunChildProcessRedirected(0, cmd); }
 #ifdef MAKENSIS
 typedef struct {
   HANDLE hNative;
@@ -112,6 +139,8 @@
 #undef _vftprintf
 #define _vftprintf WinStdIO_vfwprintf
 #endif // ~MAKENSIS
+#else
+int RunChildProcessRedirected(LPCSTR cmd);
 #endif // ~_UNICODE
 #define ResetPrintColor() FlushOutputAndResetPrintColor() // For reset ONLY, use PrintColorFmtMsg(0,NULL ...
 #define SetPrintColorWARN() PrintColorFmtMsg(1|0x10, NULL, (va_list)NULL)
@@ -245,10 +274,28 @@
 
 // round a value up to be a multiple of 512
 // assumption: T is an int type
-template <class T>
-inline T align_to_512(const T x) {
-  return (x+511) & ~511;
+template <class T> inline T align_to_512(const T x) { return (x+511) & ~511; }
+
+// some values need to be truncated from size_t to [unsigned] int, using this function is better than a plain cast
+template<class R, class T> inline R internaltruncate_cast(T t) {
+  assert((~((T)0)) > T(0)); // Only unsigned types supported right now
+  if (sizeof(T) > sizeof(R)) assert(t <= (T)(~((R)0))); // BUGBUG: What if R is a signed type?
+  return (R) t;
+}
+template<class R, class T> inline R debugtruncate_cast(T t,const char*f,unsigned int l) { 
+#ifdef MAKENSIS
+  if (sizeof(T) > sizeof(R) && !( (t <= (T)(~((R)0))) )) {
+    _tprintf(_T("unsafe truncate_cast: %") NPRIns _T(":%u\n"),f,l);
+    if (sizeof(T) <= sizeof(void*)) _tprintf(_T("\t0x%p > %0xp\n"),(void*)(UINT_PTR)(t),(void*)(UINT_PTR)(~((R)0)));
+  }
+#endif
+  return internaltruncate_cast<R>(t);
 }
+#if defined(DEBUG) || defined(_WIN64) // Always enabled for experimental 64-bit builds
+#define truncate_cast(ret_t,input) debugtruncate_cast<ret_t>((input),__FILE__,__LINE__)
+#else
+#define truncate_cast(ret_t,input) internaltruncate_cast<ret_t>((input))
+#endif
 
 // ================
 // ResourceManagers
diff -ru a/nsis-3.0a2-src/Source/winchar.cpp b/nsis-3.0a2-src/Source/winchar.cpp
--- a/nsis-3.0a2-src/Source/winchar.cpp	2013-12-08 15:34:38.000000000 +0100
+++ b/nsis-3.0a2-src/Source/winchar.cpp	2016-03-31 15:15:19.879854247 +0200
@@ -94,7 +94,7 @@
   unsigned int v = 0, base = 10, top = '9';
   int sign = 1;
   if (*s == _T('-')) ++s, sign = -1;
-  for ( unsigned int c;; )
+  for ( unsigned short int c;; )
   {
     if ((c = *s++) >= '0' && c <= top) c -= '0'; else break;
     v *= base, v += c;
diff -ru a/nsis-3.0a2-src/Source/writer.cpp b/nsis-3.0a2-src/Source/writer.cpp
--- a/nsis-3.0a2-src/Source/writer.cpp	2013-05-17 21:31:36.000000000 +0200
+++ b/nsis-3.0a2-src/Source/writer.cpp	2016-03-31 15:15:19.879854247 +0200
@@ -57,7 +57,7 @@
   if (m_build_unicode)
   {
     bool strEnd = false;
-    TCHAR ch;
+    TCHAR ch = _T('\0');
     for (; size ; size--)
     {
       if (!strEnd)
